\chapter[Monitorowania aplikacji]{Monitorowanie aplikacji}
\label{chapter:monitoring}

\begin{quote}
    I believe in having each device secured and monitoring each device, rather than just
    monitoring holistically on the network, and then responding in short enough time for damage control.
\end{quote}
% TODO(caption) add missing quotation, Kevin Mitnick

\section{Monitorowanie}
    Monitorowanie, w informatyce, nie różni się szczególnie od monitorowania w innych dziedzinach nauki lub przemysłu. 
    W najszerszym tego słowa znaczeniu, odnosi się ono uzyskania wiedzy na temat tego, co się dzieje aktualnie w systemie.
    Jest to proces, w wyniku którego możliwe jest uzyskania wiedzy na temat obciążanie systemu, rozmiarów oraz przepływu przez niego
    danych. Monitorowanie jest zestawem aplikacji z zakresu przetwarzania danych w czasie rzeczywistym oraz analizy. 
    Głównym zadaniem, jakie przyświeca omawianej gałęzi informatyki, jest alarmowania administratorów systemu o wszelkich
    odchyleniach od normy, które jeśli się utrzymają, mogą zaowocować nawet między innymi w wyłączeniu monitorowanego
    komponentu przez co niemożliwe będzie normalne praca całego systemu. Najlepszym tutaj przykładem, takiej sytuacji, 
    byłby wzrost ilości niedostarczonych wiadomości w kolejce (przykładowo Kafka lub RabbitMQ). Jeśli, wspomniana kolejka,
    stanowiłaby integralną część systemu, innymi słowy jej zadanie polegałoby na przesyłaniu danych istotnych z punktu
    widzenia użytkownika końcowego, awaria tego typu zatrzymałaby cały system \cite{monitoring_and_alerting}.
    
    \subsection{Techniki monitorowania}
    Wyróżnić można dwie podstawowe gałęzie. Podejście \textbf{pasywne} oraz \textbf{aktywne}. Oba z nich wzajemnie się uzupełniają.
    W pierwszy z nich, administrator systemu wyłączony jest z procesu monitorowania stanu dopóty, dopóki pewien
    punkty krytyczny nie zostanie przekroczony. W tym momencie wystosowywane jest powiadomienie informujący o zaistniałej
    sytuacji. Z drugiej strony, w podejściu aktywnym, administrator może na bieżąco analizować dane spływające z systemu.
    Rozwiązania monitoringu aplikacji najczęściej dostarczane są razem z programami, których celem jest 
    wizualizacji zebranych próbek w formie diagramów oraz wykresów. W połączeniu z faktem, że monitorowania odbywa się
    w czasie rzeczywistym, również administrator, w czasie rzeczywistym, może zauważyć niepokojące symptomy wskazującego
    na nieprawidłowe działania pewnych komponentów lub systemu jako całości.
    Rozwiązania pasywne utożsamiane jest z alarmowaniem, podczas gdy aktywne z monitorowaniem \cite{monitoring_and_alerting}.
    
    \subsection{Monitorowanie - części składowe}
    Niezależnie od przyjętego modelu monitoringu, niezmiennie składa się ona zawsze z metryk, danych, gdzie nadrzędną 
    ich własnością jest czas, alarmów, notyfikacji oraz agentów.
    
        \subsubsection{Agenci}
        Proces monitorowania rozpoczyna się od agentów. Jest to specjalny program, działający nieprzerwanie w systemie, którego
        zadaniem jest zbieranie informacji na temat jego działania. Warto w tym miejscu nadmienić, że agent może zbierać zarówno
        dane odnoszące się do pojedynczej aplikacji. Jego zadaniem jest, poza pobraniem danych, przetłumaczenia ich na dane 
        numeryczne. Wynika stąd pewna własność metryk - kolejne pomiary muszą być reprezentowane za pomocą wartości numerycznych.
        Nie jest to problem dla statystyk takich jak aktualnego zużycie procesora lub pamięci. Z drugiej strony, zadaniem agenta
        może być również weryfikacja czy na danej maszynie działa serwer WWW. Poniekąd zachodzi wtedy normalizacja danych. Fakt, że
        serwer działa i jest w stanie obsługiwać żądania, może być reprezentowany za pomocą liczby 1, odwrotnie 0, mogłoby sygnalizować
        przeciwny fakt. Opisany proces może zachodzić w sposób ciągły lub być okresowo wznawiany. 
        
        \subsubsection{Metryki}
        Dane zebrane od agentów, przechowywane są w formie metryk. Jest to struktura danych optymalizowana pod kątem
        efektywnego przechowywania liczb. Nie miałyby one jednak większego znaczenia bez kontekstu w którym zostały
        zabrane. Dlatego też każda pojedyncza metryka opisana jest zestawem innych wartości dającymi wgląd w takie
        informacje jak na przykład:
        \begin{itemize}
            \item miejsce pochodzenia,
            \item rodzaj metryki,
            \item data zebrania.
        \end{itemize}
        Faktyczna liczba \textit{wymiarów}\footnote{\textbf{Dimensions} - meta dane opisujące zabraną metrykę} może
        zostać dowolnie ustalana. Dzięki nim możliwe jest, w późniejszym czasie, przeglądania zebranych pomiarów
        na dowolnym poziomie agregacji. W dalszym procesie przetwarzania metryki grupowane są w serie czasowe. Ich ilość
        zależy przede wszystkim od rodzaju informacji jaką chce się uzyskać.
        
        \subsubsection{Alarmy}
        Generowane są na podstawie metryk przez oprogramowanie zwane monitorem. Alarm, jeśli zostanie wygenerowany, 
        odnosi się do sytuacji szczególnej, która zaistniała w systemie. Wspomniane aplikacje analizują wygenerowane metryki, 
        porównując otrzymana wartości z dostarczoną im konfiguracją. Bazując na niej, są w stanie stwierdzić, że jeśli
        własność A przekroczyła maksymalną lub minimalną wartość określoną ilość razy, konieczne jest poinformowania o tym
        administratora systemu. Jednocześnie alarm, najczęściej, zapisywany jest do bazy danych. Pozwala to na późniejszą analizę 
        w kontekście historycznym. 
        
        \subsubsection{Powiadomienia}
        Notyfikacje są generowane przez system monitoringu jeśli dany alarm przejdzie w stan aktywny. Mogą przyjąć praktycznie
        dowolną formę, wszystko zależy od pomysłowości programistów stojących za przygotowaniem takiego rozwiązania.
        Najczęściej spotykane jest wysłania wiadomości mailowej na wskazane adres, informując o 
        przekroczeniu pewnych wartości granicznych w określonym komponencie całego systemu. Spotyka się również inne formy:
        \begin{itemize}
            \item[SMS] - na wskazany numer telefonu wysłana jest wiadomość SMS, zawierająca skrócony opis zaistniałego problemu,
            \item[ITS] - z angielskiego - \textbf{Issue Tracking System}. Notyfikacja może przyjąć także bardziej wyrafinowaną formę.
            \textbf{ITS} są specjalnymi rodzajami stron internetowych, w których zgłaszane są wszelkie problemy, jakie napotkano
            podczas użytkowania systemu. Ich nadrzędnym celem jest dostarczenie właściwych rozwiązań administracyjnych, mających
            na celu naprawę zaistniałej sytuacji oraz późniejsze jej przeciwdziałania.
        \end{itemize}
        Mogą się one zarówno wzajemnie wykluczać, jak i uzupełniać. Alarmy mogą również same definiować jaki rodzaj notyfikacji
        powinien zostać w ich przypadku wykorzystany.
        
        \subsubsection{Wizualizacje}
        W formie graficznej, wykresów oraz diagramów, reprezentuje się serie czasowe tworzone na podstawie metryk.
    
\section{Anatomia alarmu}
\label{chapter:monitoring:anatomy_of_alarm}

    Alarm, z pominięciem jego biznesowego znaczenia, jest niczym więcej jak funkcją logiczną zwracającą:
    \begin{itemize}
        \item prawdę, wskazującą no to, że alarm jest obecnie aktywna, przekroczone zostały więc
        pewne wartości graniczne dla niego zdefiniowane,
        \item fałsz, alarm jest obecnie nieaktywny, a system lub komponent pracuje zgodnie z założeniami.
    \end{itemize}
    Czasami definiuje się funkcję, która zwrócić może 3 wartości. Dodatkowa możliwości sugeruje brak 
    potrzebnych danych, a alarm w takim wypadku, znajdować się może w stanie nieokreślonym. 
   
    \subsection{Dane wejściowe}
    Wejściem dla danej funkcji mogą być metryki, inne alarmy lub funkcje czasu. Teoretycznie jednak, nie ma ustalonej
    ilości ani rodzaju możliwych wejść, a wszystko zależy od danej implementacji. Za każdym razem, kiedy 
    zmianie ulegnie stan systemu, następuje weryfikacja ograniczeń alarmu oraz reakcji na ewentualne ich
    przekroczenie. Warto w tym miejscu nadmienić, że alarmy najczęściej dodatkowo definiują również 
    konkretną liczbę przekroczeń przed aktywacją. Bez tego rozwiązania, mogłoby dojść do sytuacji, w których
    alarmy przechodziły by bardzo często ze stanu aktywnego do spoczynku, powodując generowanie dużej ilości notyfikacji. Odwrotnie, alarm określa także jak wiele punktów nie aktywujących go, powinno
    nastąpić, aby alarm opuścił stan wysoki.
    
    \subsection{Ograniczenia}
    Ograniczenia alarmu mogą być zarówno górne (<, <=) jak i dolne (>, >=). Pierwsze z nich stosowane są
    najczęściej dla sytuacji, kiedy konieczne jest wiedza o przekraczaniu przez aplikację pewnych wartości.
    Przykładem może być zwiększony czas odpowiedzi strony. Sa to najczęściej używane limity, dzięki którym
    administrator systemu jest powiadamiany o zbyt dużym zużyciu zasobowych systemów, mogących prowadzić
    do czasowego lub całkowite jego wyłączenia. Z drugiej strony, ograniczenia dolne, najczęściej
    stosowane są do mierzenia wydajności komponentów. Przykładowo, oczekuje się, że ilość wiadomości
    przepływająca przez kolejkę będzie utrzymała się na zadanym poziomie. Znając szybkość z jaką dane 
    wpływają do niej, fakt, że szybkość z jaką ją opuszczała spadła i utrzymuje się poniżej zakładanego
    limitu, może być dla administratora sygnałem wskazującym na konieczność interwencji.
    Wspomniane ograniczenia mogą być również łączone, z użyciem alternatywy. Fakt aktywacji takiego
    alarmu może zostać wykorzystany w sposób ogólny do śledzenia wszelkich odchyleń od normy \cite{monitoring_and_alerting}.
    
    \subsection{Wiązania alarmów ze sobą}
    Ostatecznie alarmy mogą być ze sobą wiązane. Ponieważ są one, z jednego punktu widzenia, funkcją
    zwracają prawdę lub fałsz, możliwe jest aby jeden alarm był jednym ze składników wejścia innego.
    W ten sposób budowane są całe hierarchie odzwierciadlające kompleksowość systemu. 
    
    \subsection{Wykluczanie}
    
        Wykluczanie odnosi się do czasowego wymuszenia na danym alarmie pozostanie w stanie nieaktywnym.
        Może to zostać osiągnięte w sposób manualny lub automatyczny. W pierwszym wypadku konieczne jest
        aby operator wznowił działania alarmu po upływie okresu, kiedy konieczne było, aby nie
        generował on żadnych powiadomień. Wykluczania automatyczne opiera się na podstawowej własności
        alarmu - jest to funkcja logiczna. Możliwe jest więc zdefiniowane monitora - alarmu, który wchodząc
        w stan aktywności byłby informacją dla innych alarmów, aby pozostać w stanie spoczynku. Jednocześnie
        mógłby on generować notyfikacje, jeśli byłoby to konieczne. 
    
        \subsubsection{Rola funkcji czasu}
        Funkcje czasu, w przypadku wykluczeń alarmów są szczególnie użyteczne, jeśli intencją jest czasowe wyłączenie
        alarmu. Przykładowo, w godzinach nocnych najczęściej przeprowadzane operacja sprowadzają się do zadań 
        administracyjnych, indeksacji danych lub czyszczenia systemu. Zadania tego typu mogą wymagać dużo
        zasobów systemowych, zarówno w postaci czasu procesora, pamięci, przestrzeni dyskowej jak i sieci.
        Alarmy zdefiniowane dla tych zasobów mogłoby zostać więc aktywowane. Jednak, wspomniane zadania, 
        są planowane. Innymi słowy metryki, które podczas normalnego działania systemu, mogłoby wskazywać
        no poważny problem, dla wspomnianych operacji są zupełnie normalne. 
    
    \subsection{Łączenie}
    \label{chapter:monitoring:anatomy_of_alarm:assocation}
    
        Alarmy najczęściej odnoszą się do pojedynczej metryki, jednak jedną z możliwości, jakie alarm może
        oferować jest łączenie metryk poprzez alarmy na zasadach podobnych do łączenia wyrażeń
        logicznych w algebrze Bool'a. Główną zaletą agregowania alarmów jest minimalizacja powiadomień, 
        które dotyczą tego samego, a gdzie jedyną różnicą jest miejsce, serwer na którym nastąpiło
        przekroczenie wartości granicznych. 
    
        \subsubsection{Koniunkcja}
        \label{chapter:monitoring:anatomy_of_alarm:assocation:and}
        Dla tego typu asocjacji, alarm przechodzi w stan aktywny tylko wtedy, jeśli wszystkie wyrażenia
        zwracają logiczną wartość \textbf{Prawda}. Matematycznie, powyższe twierdzenie, przyjmuje postać
        \mint{text}|wynik=(Alarm1 AND Alarm2 AND ... AND AlarmN)|
        Tego typu alarmy nadają się idealnie
        do monitorowania stanu klastra. Przykładowo, powiadomienie mogłoby zostać wysłana dopiero 
        wtedy, kiedy każda z maszyn będących jego częścią, przestałaby odpowiadać. Innymi słowy,
        alarm zdefiniowany dla każdego hosta wszedłby w stan aktywny. Wynika z tego, że koniunkcja
        w przypadku alarmów, jest idealnym rozwiązaniem jeśli monitoruje się stan więcej niż jednego
        komponentu, z których każdy może ulec awarii, co jednak nie wpłynie na stan całego klastra, dopóki
        dopóty pozostałe maszyny działają.
        
        \subsubsection{Alternatywa}
        Odwrotność dla koniunkcji. Matematycznie reprezentowana za pomocą wyrażenia
        \mint{text}|wynik=(Alarm1 OR Alarm2 OR ... OR AlarmN)|
        Zgodnie z logiką Bool'a, wystarczy aby jeden
        składnik wyrażenia był logiczną \textbf{Prawdą}, aby całość przyjęła taką samą wartość. \textbf{Alternatywa},
        nadaje się dla definiowania alarmów, gdzie każda z monitorowanych encji ma krytyczne znaczenia dla działania całego systemu.
        Powołując się na przykład opisany w \ref{chapter:monitoring:anatomy_of_alarm:assocation:and}, tego typu
        alarm mógłby wejść w stan aktywny jeśli klaster komponentu A (serwer bazy danych) przestał działać. W tym momencie pozostałe
        elementy, również zgrupowane, lub nie, w klaster zaczęły by zgłaszać błędy, wynikającej z utraconej łączności
        z bazą danych.
        
        \subsubsection{Zliczanie}
        Stanowi kompromis między \textbf{koniunkcją} a \textbf{alternatywą}. Podczas gdy pierwszy rodzaj łączenia, działa
        w imię zasady - wszystko albo nic, a w przypadku drugiego, wystarczy tylko jeden, zliczania oferuje możliwość
        zdefiniowania minimalnej liczby warunków do spełniania, aby alarm przeszedł w stan aktywny.
        Matematyczny zapis wygląda następująco
        \mint{text}|wynik=[(Alarm1 + Alarm2 + ... + AlarmN) >= K]|
        Innymi słowy, operator, może zdefiniować alarm następującej postaci. Jeśli na 4 z 5 serwerów, zużycia przestrzeni dyskowej
        wzrośnie powyżej 80 procent, należy automatycznie uruchomić procedurę archiwizacji danych \cite{monitoring_and_alerting}. 

\section{Korzyści monitorowania - zalety i wady}
\label{chapter:monitoring:advantages}

    \subsection{Wczesne wykrycie problemu}
    \label{chapter:monitoring:advantages:early_detection}
    Jednocześnie podstawowa cecha oraz korzyść wynikająca z posiadania systemu monitorowania. 
    Jest to także najbardziej krytyczna funkcja w której stykają się problemy odnoszące się
    do szybkości, dokładności oraz wydajności. Im szybciej administrator zostanie
    powiadomiony o potencjalnym problemie, tym większa szansa, że uda uniknąć się potencjalnej
    awarii systemu lub jej skutki będą zminimalizowane. Niestety, w tym samym czasie, 
    aby system monitorowania mógł dokładnie określić, że obserwowana sytuacja odbiega od normy,
    musi on zebrać więcej niż kilka próbek. Uzyskania zadanej dokładności wymaga czasu, 
    przez co szybkość detekcji spada. Ponadto, podobnie jak każdy program, również procesu
    monitoringu zajmują czas procesora oraz pamięć. Im bardziej skomplikowany jest algorytm
    detekcji tym większych zasobów systemu może on wymagać. Oczywistym jest, że wymaganiem
    stawianym twórców tego typu oprogramowania jest dostarczenie wymaganej funkcjonalności
    bez zbyt dużego wpływu na wydajności docelowego systemu \cite{monitoring_and_alerting}. 
    
    \subsection{Wysoka dostępność}
    \label{chapter:monitoring:advantages:high_availability}
    Zapewnienie ciągłości w świadczeniu usługi jest możliwe dzięki wczesnej detekcji
    wszelkich sytuacji anormalnych (\ref{chapter:monitoring:advantages:early_detection}) w kontekście danego systemu. 
    Termin, mimo ogólności, jest szczególnie istotny w przypadku usług działających w chmurach, dostępnych
    dla szerokiego grona użytkowników. Awaria systemu, w takim przypadku, jest sytuacją niedopuszczalną. Dlatego
    też podejmowane są wszelkie kroki, pozwalające świadczyć usługi bez przerwy. Dzięki możliwości
    monitorowania systemu i wynikającej z tego korzyści jaką niesie wiedza o jego stania, pozwala
    administratorom na aktywne przeciwdziałania tego typu sytuacjom \cite{monitoring_and_alerting}. 
    
    \subsection{Automatyzacja}
    Uzyskania wysokiej dostępności w sposób ręczny, z udziałem czynnika ludzkiego, jest praktycznie niemożliwe.
    Mimo, że to właśnie człowiek jest w stanie zrozumieć przyczyny problemu aby zapobiec ich ponownemu wystąpieniu, 
    nie jest on zdolny do zapewnienia, że system będzie świadczył usługę nieprzerwania. Wysoka dostępność (\ref{chapter:monitoring:advantages:high_availability}) tożsama jest z automatycznym procesem, w wyniku którego
    komponent zgłaszający problem, może zostać wyłączony lub odłączony od reszty systemu i zastąpiony inną instancją.
    Rozwiązania tego typu są najczęściej oparte o technologie takie jak \textbf{Docker}, gdzie gotowy system
    operacyjny wraz z przygotowaną aplikacją zapisane są w kontenerze (podobnym do maszyny wirtualnej), który po 
    uruchomieniu jest natychmiast gotowy do pracy. Nie tylko zastępowania komponentów jest możliwe. Dzięki
    danym napływającym z monitorowania, wskazującym na wyższe obciążania systemu, możliwe jest uruchomienie
    kolejnych instancji, które wspomogą już działające, a zwiększony ruch zostanie rozłożony na więcej elementów,
    przez co sumarycznie poszczególnie instancje zaczną działać pod mniejszym obciążaniem. Odwracając sytuację, jeśli
    dodatkowe instancje nie będą już potrzebne mogą zostać one automatycznie wyłączone. Taki rodzaj pracy, jest również
    znany pod nazwą oprogramowania autonomicznego, zdolnego do samodzielnego skalowania oraz przywracania do stanu równowagi 
    \cite{monitoring_and_alerting}. 
    
    \todo[inline]{czy opisywać te dalsze również?}
    
    \subsection{Tuningowanie systemu}
    \subsection{Podejmowanie decyzji}